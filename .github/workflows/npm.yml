name: Publish and Deploy

on:
  push:
    branches: [ master ]
  schedule:
    - cron: "*/15 * * * *"

concurrency:
  group: publish-and-deploy
  cancel-in-progress: false

jobs:
  check:
    name: Check whether build should run
    runs-on: ubuntu-slim
    permissions:
      actions: read
      contents: read
    outputs:
      should_run: ${{ steps.gate.outputs.should_run }}
      matched_run_id: ${{ steps.gate.outputs.matched_run_id }}
      matched_time: ${{ steps.gate.outputs.matched_time }}
      blocked_by_run_id: ${{ steps.gate.outputs.blocked_by_run_id }}
      blocked_by_job: ${{ steps.gate.outputs.blocked_by_job }}
    steps:
      - name: Decide whether build should run
        id: gate
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          WORKFLOW_FILE: npm.yml
          TARGET_JOB_NAME: prepare
          MIN_SECONDS: "3600"
          CURRENT_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          now="$(date -u +%s)"

          # Default policy: "If there is no previous successful build, run the first build"
          should_run="true"
          matched_run_id=""
          matched_time=""
          found_any_success="false"

          # --- Block if another run is already past prepare (or is in prepare) ---
          # If any job among prepare/lint/build/purge is queued or in_progress in another run,
          # skip this run immediately to avoid duplicate publish/deploy.
          BLOCK_JOB_NAMES_REGEX='^(prepare|lint|build|purge)$'
          blocked_by_run_id=""
          blocked_by_job=""

          for st in in_progress queued; do
            while read -r other_run_id; do
              [ -n "$other_run_id" ] || continue
              [ "$other_run_id" = "$CURRENT_RUN_ID" ] && continue

              jobs="$(gh api -H "Accept: application/vnd.github+json" \
                "/repos/${REPO}/actions/runs/${other_run_id}/jobs?per_page=100")"

              hit="$(echo "$jobs" | jq -r --arg re "$BLOCK_JOB_NAMES_REGEX" '
                .jobs[]
                | select(.name | test($re))
                | select(.status == "queued" or .status == "in_progress")
                | "\(.name) \(.status)"' | head -n 1 || true)"

              if [ -n "$hit" ]; then
                blocked_by_run_id="$other_run_id"
                blocked_by_job="$hit"
                break 2
              fi
            done < <(
              gh api --paginate -H "Accept: application/vnd.github+json" \
                "/repos/${REPO}/actions/workflows/${WORKFLOW_FILE}/runs?status=${st}&per_page=100" \
              | jq -r '.workflow_runs[].id'
            )
          done

          if [ -n "$blocked_by_run_id" ]; then
            echo "Found another active run past prepare; skipping this run."
            should_run="false"

            echo "should_run=$should_run" >> "$GITHUB_OUTPUT"
            echo "matched_run_id=$matched_run_id" >> "$GITHUB_OUTPUT"
            echo "matched_time=$matched_time" >> "$GITHUB_OUTPUT"
            echo "blocked_by_run_id=$blocked_by_run_id" >> "$GITHUB_OUTPUT"
            echo "blocked_by_job=$blocked_by_job" >> "$GITHUB_OUTPUT"
            echo "found_any_success=$found_any_success" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # --- end block ---

          # --- Time gate: find latest successful TARGET_JOB_NAME in completed runs ---
          while read -r run_id concl updated_at; do
            [ -n "$run_id" ] || continue
            [ "$run_id" = "$CURRENT_RUN_ID" ] && continue

            # âœ… Exclude workflow failures: failure/cancelled/timed_out/action_required
            case "$concl" in
              failure|cancelled|timed_out|action_required)
                continue
                ;;
            esac

            # Check if the build job in this run was successful
            jobs="$(gh api -H "Accept: application/vnd.github+json" \
              "/repos/${REPO}/actions/runs/${run_id}/jobs?per_page=100")"

            job_concl="$(echo "$jobs" | jq -r --arg NAME "$TARGET_JOB_NAME" \
              '.jobs[] | select(.name == $NAME) | .conclusion' | head -n 1 || true)"

            [ "$job_concl" = "success" ] || continue

            found_any_success="true"
            matched_run_id="$run_id"
            matched_time="$updated_at"

            past="$(date -u -d "$updated_at" +%s 2>/dev/null || true)"
            [ -n "$past" ] || break

            elapsed=$(( now - past ))

            # If the last successful build was more than 1 hour ago, run; otherwise, skip
            if [ "$elapsed" -ge "$MIN_SECONDS" ]; then
              should_run="true"
            else
              should_run="false"
            fi
            break
          done < <(
            gh api --paginate -H "Accept: application/vnd.github+json" \
              "/repos/${REPO}/actions/workflows/${WORKFLOW_FILE}/runs?status=completed&per_page=100" \
            | jq -r '.workflow_runs[] | "\(.id) \(.conclusion) \(.updated_at)"'
          )

          echo "should_run=$should_run" >> "$GITHUB_OUTPUT"
          echo "matched_run_id=$matched_run_id" >> "$GITHUB_OUTPUT"
          echo "matched_time=$matched_time" >> "$GITHUB_OUTPUT"
          echo "blocked_by_run_id=$blocked_by_run_id" >> "$GITHUB_OUTPUT"
          echo "blocked_by_job=$blocked_by_job" >> "$GITHUB_OUTPUT"
          echo "found_any_success=$found_any_success" >> "$GITHUB_OUTPUT"

  prepare:
    name: Print decision info
    needs: check
    if: needs.check.outputs.should_run == 'true'
    runs-on: ubuntu-slim
    permissions:
      contents: none
    steps:
      - name: Print decision info
        run: |
          echo "Matched run id: ${{ needs.check.outputs.matched_run_id }}"
          echo "Matched time:   ${{ needs.check.outputs.matched_time }}"
  lint:
    name: Run AGLint
    needs: prepare
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Check out to repository
        uses: actions/checkout@v6

      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'

      - name: Install dependencies
        run: npm install

      # If the linter found any errors, it will exit with a non-zero code,
      # which will cause the job to fail
      - name: Run AGLint
        run: npm run lint
  build:
    name: Build and Publish to npm
    needs: lint
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Set up Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'
          registry-url: 'https://registry.npmjs.org'
      - name: Check out to repository
        uses: actions/checkout@v6
      - name: Install dependencies
        run: npm install
      - name: Build
        run: npm run build
      - name : Publish to npm
        run: npm publish --tag latest --access public
  purge:
    name: Purge jsdelivr cache
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - name: Set up NodeJS LTS
        uses: actions/setup-node@v6
        with:
          node-version: 'lts/*'
      - name: Purge jsdelivr cache
        uses: FilteringDev/jsdelivr-purge-npm@1.0.7
        with:
          package: '@list-kr/filterslists'
          disttag: 'latest'
    needs: build
  
